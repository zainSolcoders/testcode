import { Flags } from '@oclif/core';
import { path, schema, file, dependency, dotenv, error, toml, string } from '@shopify/cli-kit';

const appFlags = {
  path: Flags.string({
    hidden: false,
    description: "The path to your app directory.",
    parse: (input, _) => Promise.resolve(path.resolve(input)),
    env: "SHOPIFY_FLAG_PATH"
  })
};

const configurationFileNames = {
  app: "shopify.app.toml",
  extension: {
    ui: "shopify.ui.extension.toml",
    theme: "shopify.theme.extension.toml",
    function: "shopify.function.extension.toml"
  },
  web: "shopify.web.toml"
};
const dotEnvFileNames = {
  production: ".env"
};
const environmentVariables = {
  useExtensionsCLISources: "SHOPIFY_USE_EXTENSIONS_CLI_SOURCES"
};
const versions = {
  extensionsBinary: "v0.13.0"
};
const blocks = {
  extensions: {
    directoryName: "extensions",
    configurationName: configurationFileNames.extension
  },
  functions: {
    defaultUrl: "https://github.com/Shopify/scripts-apis-examples",
    defaultLanguage: "wasm"
  },
  web: {
    directoryName: "web",
    configurationName: configurationFileNames.web
  }
};
const limitedExtensions = {
  ui: ["product_subscription", "checkout_post_purchase"],
  theme: ["theme"],
  function: []
};
const genericConfigurationFileNames = {
  yarn: {
    lockfile: "yarn.lock"
  },
  pnpm: {
    lockfile: "pnpm-lock.yaml"
  }
};
const functionExtensions = {
  types: ["product_discounts", "order_discounts", "shipping_discounts", "payment_methods", "shipping_rate_presenter"]
};
const uiExtensions = {
  types: ["product_subscription", "checkout_ui_extension", "checkout_post_purchase", "beacon_extension"]
};
const themeExtensions = {
  types: ["theme"]
};
const extensions = {
  types: [...themeExtensions.types, ...uiExtensions.types, ...functionExtensions.types]
};
function extensionTypeCategory(extensionType) {
  if (extensionType === "theme") {
    return "theme";
  }
  if (functionExtensions.types.includes(extensionType)) {
    return "function";
  }
  return "ui";
}
function getUIExtensionRendererDependency(extensionType) {
  switch (extensionType) {
    case "product_subscription":
      return "@shopify/admin-ui-extensions-react";
    case "checkout_ui_extension":
      return "@shopify/checkout-ui-extensions-react";
    case "checkout_post_purchase":
      return "@shopify/post-purchase-ui-extensions-react";
    case "beacon_extension":
      return void 0;
  }
}

const WebConfigurationFileNotFound = (directory) => {
  return new error.Abort(`Couldn't find ${configurationFileNames.web} in ${directory}`);
};
const AppConfigurationSchema = schema.define.object({
  scopes: schema.define.string().default("")
});
const UIExtensionConfigurationSchema = schema.define.object({
  name: schema.define.string(),
  type: schema.define.enum(uiExtensions.types),
  metafields: schema.define.array(schema.define.object({
    namespace: schema.define.string(),
    key: schema.define.string()
  })).default([])
});
const FunctionExtensionConfigurationSchema = schema.define.object({
  name: schema.define.string(),
  type: schema.define.enum(functionExtensions.types),
  title: schema.define.string()
});
const ThemeExtensionConfigurationSchema = schema.define.object({
  name: schema.define.string(),
  type: schema.define.enum(themeExtensions.types)
});
var WebType = /* @__PURE__ */ ((WebType2) => {
  WebType2["Frontend"] = "frontend";
  WebType2["Backend"] = "backend";
  return WebType2;
})(WebType || {});
const WebConfigurationSchema = schema.define.object({
  type: schema.define.enum(["frontend" /* Frontend */, "backend" /* Backend */]),
  commands: schema.define.object({
    build: schema.define.string().optional(),
    dev: schema.define.string()
  })
});
class AppErrors {
  constructor() {
    this.errors = {};
  }
  addError(path2, message) {
    this.errors[path2] = message;
  }
  getError(path2) {
    return this.errors[path2];
  }
  isEmpty() {
    return Object.keys(this.errors).length === 0;
  }
  toJSON() {
    return Object.values(this.errors);
  }
}
class AppLoader {
  constructor({ directory, mode }) {
    this.appDirectory = "";
    this.configurationPath = "";
    this.errors = new AppErrors();
    this.mode = mode;
    this.directory = directory;
  }
  async loaded() {
    this.appDirectory = await this.findAppDirectory();
    const configurationPath = await this.getConfigurationPath();
    const configuration = await this.parseConfigurationFile(AppConfigurationSchema, configurationPath);
    const extensionsPath = path.join(this.appDirectory, `${blocks.extensions.directoryName}`);
    const environment = await this.loadEnvironment();
    const functions = await this.loadFunctions(extensionsPath);
    const uiExtensions2 = await this.loadUIExtensions(extensionsPath);
    const themeExtensions2 = await this.loadThemeExtensions(extensionsPath);
    const yarnLockPath = path.join(this.appDirectory, genericConfigurationFileNames.yarn.lockfile);
    const yarnLockExists = await file.exists(yarnLockPath);
    const pnpmLockPath = path.join(this.appDirectory, genericConfigurationFileNames.pnpm.lockfile);
    const pnpmLockExists = await file.exists(pnpmLockPath);
    const packageJSONPath = path.join(this.appDirectory, "package.json");
    const name = await dependency.getPackageName(packageJSONPath);
    const nodeDependencies = await dependency.getDependencies(packageJSONPath);
    let dependencyManager;
    if (yarnLockExists) {
      dependencyManager = "yarn";
    } else if (pnpmLockExists) {
      dependencyManager = "pnpm";
    } else {
      dependencyManager = "npm";
    }
    const app = {
      name,
      idEnvironmentVariableName: "SHOPIFY_APP_API_KEY",
      directory: this.appDirectory,
      webs: await this.loadWebs(),
      configuration,
      configurationPath,
      environment,
      extensions: { ui: uiExtensions2, theme: themeExtensions2, function: functions },
      dependencyManager,
      nodeDependencies
    };
    if (!this.errors.isEmpty())
      app.errors = this.errors;
    return app;
  }
  async loadEnvironment(systemEnv = process.env) {
    const env = Object.fromEntries(Object.entries(systemEnv).filter(([key, value]) => {
      return key.startsWith("SHOPIFY_") && value;
    }));
    let productionEnv;
    const productionEnvPath = path.join(this.appDirectory, dotEnvFileNames.production);
    if (await file.exists(productionEnvPath)) {
      productionEnv = await dotenv.read(productionEnvPath);
    }
    return {
      dotenv: {
        production: productionEnv
      },
      env
    };
  }
  async findAppDirectory() {
    if (!await file.exists(this.directory)) {
      throw new error.Abort(`Couldn't find directory ${this.directory}`);
    }
    return path.dirname(await this.getConfigurationPath());
  }
  async getConfigurationPath() {
    if (this.configurationPath)
      return this.configurationPath;
    const configurationPath = await path.findUp(configurationFileNames.app, {
      cwd: this.directory,
      type: "file"
    });
    if (!configurationPath) {
      throw new error.Abort(`Couldn't find the configuration file for ${this.directory}, are you in an app directory?`);
    }
    this.configurationPath = configurationPath;
    return configurationPath;
  }
  async loadWebs() {
    const webTomlPaths = await path.glob(path.join(this.appDirectory, `**/${configurationFileNames.web}`));
    if (webTomlPaths.length === 0) {
      throw WebConfigurationFileNotFound(this.appDirectory);
    }
    const webs = await Promise.all(webTomlPaths.map((path2) => this.loadWeb(path2)));
    return webs;
  }
  async loadWeb(WebConfigurationFile) {
    return {
      directory: path.dirname(WebConfigurationFile),
      configuration: await this.parseConfigurationFile(WebConfigurationSchema, WebConfigurationFile)
    };
  }
  async loadConfigurationFile(path2) {
    if (!await file.exists(path2)) {
      return this.abortOrReport(`Couldn't find the configuration file at ${path2}`, "", path2);
    }
    const configurationContent = await file.read(path2);
    return {
      ...Object.fromEntries(Object.entries(toml.decode(configurationContent)).map((kv) => [string.camelize(kv[0]), kv[1]]))
    };
  }
  async parseConfigurationFile(schema2, path2) {
    const fallbackOutput = {};
    const configurationObject = await this.loadConfigurationFile(path2);
    if (!configurationObject)
      return fallbackOutput;
    const parseResult = schema2.safeParse(configurationObject);
    if (!parseResult.success) {
      return this.abortOrReport(`Invalid schema in ${path2}:
${JSON.stringify(parseResult.error.issues, null, 2)}`, fallbackOutput, path2);
    }
    return parseResult.data;
  }
  async loadUIExtensions(extensionsPath) {
    const extensionConfigPaths = path.join(extensionsPath, `*/${configurationFileNames.extension.ui}`);
    const configPaths = await path.glob(extensionConfigPaths);
    const extensions = configPaths.map(async (configurationPath) => {
      const directory = path.dirname(configurationPath);
      const configuration = await this.parseConfigurationFile(UIExtensionConfigurationSchema, configurationPath);
      return {
        idEnvironmentVariableName: `SHOPIFY_${string.constantize(path.basename(directory))}_ID`,
        directory,
        configuration,
        configurationPath,
        buildDirectory: path.join(directory, "build"),
        entrySourceFilePath: path.join(directory, "src/index.js"),
        localIdentifier: path.basename(directory)
      };
    });
    return Promise.all(extensions);
  }
  async loadFunctions(extensionsPath) {
    const functionConfigPaths = await path.join(extensionsPath, `*/${configurationFileNames.extension.function}`);
    const configPaths = await path.glob(functionConfigPaths);
    const functions = configPaths.map(async (configurationPath) => {
      const directory = path.dirname(configurationPath);
      const configuration = await this.parseConfigurationFile(FunctionExtensionConfigurationSchema, configurationPath);
      return {
        directory,
        configuration,
        configurationPath,
        idEnvironmentVariableName: `SHOPIFY_${string.constantize(path.basename(directory))}_ID`,
        localIdentifier: path.basename(directory)
      };
    });
    return Promise.all(functions);
  }
  async loadThemeExtensions(extensionsPath) {
    const themeConfigPaths = await path.join(extensionsPath, `*/${configurationFileNames.extension.theme}`);
    const configPaths = await path.glob(themeConfigPaths);
    const themeExtensions2 = configPaths.map(async (configurationPath) => {
      const directory = path.dirname(configurationPath);
      const configuration = await this.parseConfigurationFile(ThemeExtensionConfigurationSchema, configurationPath);
      return {
        directory,
        configuration,
        configurationPath,
        idEnvironmentVariableName: `SHOPIFY_${string.constantize(path.basename(directory))}_ID`,
        localIdentifier: path.basename(directory)
      };
    });
    return Promise.all(themeExtensions2);
  }
  abortOrReport(errorMessage, fallback, configurationPath) {
    if (this.mode === "strict") {
      throw new error.Abort(errorMessage);
    } else {
      this.errors.addError(configurationPath, errorMessage);
      return fallback;
    }
  }
}
async function updateDependencies(app) {
  const nodeDependencies = await dependency.getDependencies(path.join(app.directory, "package.json"));
  return {
    ...app,
    nodeDependencies
  };
}
async function updateAppIdentifiers({
  app,
  identifiers,
  environmentType
}) {
  const envVariables = Object.keys(app.environment.env);
  let dotenvFile = app.environment.dotenv.production;
  if (!dotenvFile) {
    dotenvFile = {
      path: path.join(app.directory, dotEnvFileNames.production),
      variables: {}
    };
  }
  const variables = {};
  if (!envVariables.includes(app.idEnvironmentVariableName)) {
    variables[app.idEnvironmentVariableName] = identifiers.app;
  }
  Object.keys(identifiers.extensions).forEach((identifier) => {
    const envVariable = `SHOPIFY_${string.constantize(identifier)}_ID`;
    if (!envVariables.includes(envVariable)) {
      variables[envVariable] = identifiers.extensions[identifier];
    }
  });
  const write = JSON.stringify(dotenvFile.variables) !== JSON.stringify(variables);
  dotenvFile.variables = variables;
  if (write) {
    await dotenv.write(dotenvFile);
  }
  return {
    ...app,
    environment: {
      env: app.environment.env,
      dotenv: {
        production: dotenvFile
      }
    }
  };
}
function getAppIdentifiers({ app, environmentType }) {
  const envVariables = {
    ...app.environment.env,
    ...app.environment.dotenv.production?.variables
  };
  const extensionsIdentifiers = {};
  const processExtension = (extension) => {
    if (Object.keys(envVariables).includes(extension.idEnvironmentVariableName)) {
      extensionsIdentifiers[extension.localIdentifier] = envVariables[extension.idEnvironmentVariableName];
    }
  };
  app.extensions.ui.forEach(processExtension);
  app.extensions.function.forEach(processExtension);
  app.extensions.theme.forEach(processExtension);
  return {
    app: envVariables[app.idEnvironmentVariableName],
    extensions: extensionsIdentifiers
  };
}
function getUIExtensionRendererVersion(uiExtensionType, app) {
  const nodeDependencies = app.nodeDependencies;
  const rendererDependencyName = getUIExtensionRendererDependency(uiExtensionType);
  if (!rendererDependencyName) {
    return void 0;
  }
  const rendererDependency = nodeDependencies[rendererDependencyName];
  if (!rendererDependency) {
    return void 0;
  }
  return { name: rendererDependencyName, version: rendererDependency };
}
async function load(directory, mode = "strict") {
  const loader = new AppLoader({ directory, mode });
  return loader.loaded();
}

export { WebType as W, appFlags as a, updateAppIdentifiers as b, getAppIdentifiers as c, uiExtensions as d, environmentVariables as e, functionExtensions as f, getUIExtensionRendererVersion as g, configurationFileNames as h, extensions as i, extensionTypeCategory as j, blocks as k, load as l, getUIExtensionRendererDependency as m, limitedExtensions as n, themeExtensions as t, updateDependencies as u, versions as v };
//# sourceMappingURL=app-e1e50846.js.map
