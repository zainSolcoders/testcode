import { i as extensions, j as extensionTypeCategory, k as blocks, m as getUIExtensionRendererDependency, a as appFlags, l as load, n as limitedExtensions } from '../../../app-e1e50846.js';
import { ui, template, dependency, yaml, environment, file, path, git, string, error, cli, output } from '@shopify/cli-kit';
import { r as runGoExtensionsCLI } from '../../../cli-852b5950.js';
import { fileURLToPath } from 'url';
import stream from 'node:stream';
import { Flags, Command } from '@oclif/core';
import 'node:zlib';
import 'node:fs';
import 'node:util';

const scaffoldExtensionPrompt = async (options, prompt = ui.prompt) => {
  const questions = [];
  if (!options.extensionType) {
    questions.push({
      type: "select",
      name: "extensionType",
      message: "Type of extension?",
      choices: extensions.types.filter((type) => !options.extensionTypesAlreadyAtQuota.includes(type))
    });
  }
  if (!options.name) {
    questions.push({
      type: "input",
      name: "name",
      message: "Your extension's working name?",
      default: "extension"
    });
  }
  const promptOutput = await prompt(questions);
  return { ...options, ...promptOutput };
};

async function getTemplatePath(name) {
  const templatePath = await path.findUp(`templates/${name}`, {
    cwd: path.dirname(fileURLToPath(import.meta.url)),
    type: "directory"
  });
  if (templatePath) {
    return templatePath;
  } else {
    throw new error.Bug(`Couldn't find the template ${name} in @shopify/app.`);
  }
}
async function extensionInit(options) {
  switch (extensionTypeCategory(options.extensionType)) {
    case "theme":
      await themeExtensionInit(options);
      break;
    case "function":
      await functionExtensionInit(options);
      break;
    case "ui":
      await uiExtensionInit(options);
      break;
  }
}
async function themeExtensionInit({ name, app, extensionType }) {
  const extensionDirectory = await ensureExtensionDirectoryExists({ app, name });
  const templatePath = await getTemplatePath("theme-extension");
  await template.recursiveDirectoryCopy(templatePath, extensionDirectory, { name, extensionType });
}
async function uiExtensionInit({ name, extensionType, app }) {
  const extensionDirectory = await ensureExtensionDirectoryExists({ app, name });
  const list = new ui.Listr([
    {
      title: "Installing additional dependencies",
      task: async (_, task) => {
        const requiredDependencies = getRuntimeDependencies({ extensionType });
        await dependency.addNPMDependenciesIfNeeded(requiredDependencies, {
          dependencyManager: app.dependencyManager,
          type: "prod",
          directory: app.directory,
          stderr: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          }),
          stdout: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          })
        });
        task.title = "Dependencies installed";
      }
    },
    {
      title: "Scaffolding extension",
      task: async (_, task) => {
        const stdin = yaml.encode({
          extensions: [
            {
              title: name,
              type: `${extensionType}_next`,
              metafields: [],
              development: {
                root_dir: "."
              }
            }
          ]
        });
        await runGoExtensionsCLI(["create", "-"], {
          cwd: extensionDirectory,
          stderr: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          }),
          stdout: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          }),
          stdin
        });
      }
    }
  ], { rendererSilent: environment.local.isUnitTest() });
  await list.run();
}
function getRuntimeDependencies({ extensionType }) {
  switch (extensionType) {
    case "product_subscription":
    case "checkout_ui_extension":
    case "checkout_post_purchase": {
      const dependencies = ["react"];
      const rendererDependency = getUIExtensionRendererDependency(extensionType);
      if (rendererDependency) {
        dependencies.push(rendererDependency);
      }
      return dependencies;
    }
    case "beacon_extension":
      return [];
  }
}
async function functionExtensionInit(options) {
  const extensionDirectory = await ensureExtensionDirectoryExists(options);
  const url = options.cloneUrl || blocks.functions.defaultUrl;
  await file.inTemporaryDirectory(async (tmpDir) => {
    const templateDownloadDir = path.join(tmpDir, "download");
    const list = new ui.Listr([
      {
        title: "Scaffolding extension",
        task: async () => {
          await file.mkdir(templateDownloadDir);
          await git.downloadRepository({ repoUrl: url, destination: templateDownloadDir });
          const origin = path.join(templateDownloadDir, functionTemplatePath(options));
          template.recursiveDirectoryCopy(origin, extensionDirectory, options);
        }
      }
    ], { rendererSilent: environment.local.isUnitTest() });
    await list.run();
  });
}
function functionTemplatePath({ extensionType, language }) {
  const lang = language || blocks.functions.defaultLanguage;
  switch (extensionType) {
    case "product_discounts":
      return `discounts/${lang}/product-discounts/default`;
    case "order_discounts":
      return `discounts/${lang}/order-discounts/default`;
    case "shipping_discounts":
      return `discounts/${lang}/shipping-discounts/default`;
    case "payment_methods":
      return `checkout/${lang}/payment-methods/default`;
    case "shipping_rate_presenter":
      return `checkout/${lang}/shipping-rate-presenter/default`;
  }
}
async function ensureExtensionDirectoryExists({ name, app }) {
  const hyphenizedName = string.hyphenize(name);
  const extensionDirectory = path.join(app.directory, blocks.extensions.directoryName, hyphenizedName);
  if (await file.exists(extensionDirectory)) {
    throw new error.Abort(`Extension ${hyphenizedName} already exists!`);
  }
  await file.mkdir(extensionDirectory);
  return extensionDirectory;
}

const _AppScaffoldExtension = class extends Command {
  async run() {
    const { flags } = await this.parse(_AppScaffoldExtension);
    const directory = flags.path ? path.resolve(flags.path) : process.cwd();
    const app = await load(directory);
    this.validateType(app, flags.type);
    const promptAnswers = await scaffoldExtensionPrompt({
      extensionType: flags.type,
      extensionTypesAlreadyAtQuota: this.limitedExtensionsAlreadyScaffolded(app),
      name: flags.name
    });
    await extensionInit({
      ...promptAnswers,
      app,
      cloneUrl: flags["clone-url"],
      language: flags.language
    });
    output.info(output.content`Extension ${promptAnswers.name} generated successfully!`);
  }
  validateType(app, type) {
    if (type && this.limitedExtensionsAlreadyScaffolded(app).includes(type)) {
      throw new error.Abort("Invalid extension type", `You can only scaffold one extension of type ${type} per app`);
    }
  }
  limitedExtensionsAlreadyScaffolded(app) {
    const themeTypes = app.extensions.theme.map((ext) => ext.configuration.type);
    const uiTypes = app.extensions.ui.map((ext) => ext.configuration.type);
    const themeExtensions = themeTypes.filter((type) => limitedExtensions.theme.includes(type));
    const uiExtensions = uiTypes.filter((type) => limitedExtensions.ui.includes(type));
    return [...themeExtensions, ...uiExtensions];
  }
};
let AppScaffoldExtension = _AppScaffoldExtension;
AppScaffoldExtension.description = "Scaffold an Extension";
AppScaffoldExtension.examples = ["<%= config.bin %> <%= command.id %>"];
AppScaffoldExtension.flags = {
  ...cli.globalFlags,
  ...appFlags,
  type: Flags.string({
    char: "t",
    hidden: false,
    description: "Extension type",
    options: extensions.types,
    env: "SHOPIFY_FLAG_EXTENSION_TYPE"
  }),
  name: Flags.string({
    char: "n",
    hidden: false,
    description: "name of your Extension",
    env: "SHOPIFY_FLAG_NAME"
  }),
  "clone-url": Flags.string({
    hidden: true,
    char: "u",
    description: "The Git URL to clone the function extensions templates from. Defaults to: https://github.com/Shopify/scripts-apis-examples",
    env: "SHOPIFY_FLAG_CLONE_URL"
  }),
  language: Flags.string({
    hidden: true,
    char: "l",
    options: ["wasm", "rust", "typescript"],
    description: "Language of the template",
    env: "SHOPIFY_FLAG_LANGUAGE"
  })
};
AppScaffoldExtension.args = [{ name: "file" }];

export { AppScaffoldExtension as default };
//# sourceMappingURL=extension.js.map
