import { api, error, ui, output, session, store, environment } from '@shopify/cli-kit';
import { b as updateAppIdentifiers, c as getAppIdentifiers } from './app-e1e50846.js';

const NoOrgError = () => new error.Abort("No Organization found", "You need to create a Shopify Partners organization: https://partners.shopify.com/signup ");
async function fetchOrganizations(token) {
  const query = api.graphql.AllOrganizationsQuery;
  const result = await api.partners.request(query, token);
  const organizations = result.organizations.nodes;
  if (organizations.length === 0)
    throw NoOrgError();
  return organizations;
}
async function fetchOrgAndApps(orgId, token) {
  const query = api.graphql.FindOrganizationQuery;
  const result = await api.partners.request(query, token, { id: orgId });
  const org = result.organizations.nodes[0];
  if (!org)
    throw NoOrgError();
  const parsedOrg = { id: org.id, businessName: org.businessName };
  return { organization: parsedOrg, apps: org.apps.nodes, stores: [] };
}
async function fetchAppFromApiKey(apiKey, token) {
  const res = await api.partners.request(api.graphql.FindAppQuery, token, { apiKey });
  return res.app;
}
async function fetchAllStores(orgId, token) {
  const query = api.graphql.AllStoresByOrganizationQuery;
  const result = await api.partners.request(query, token, { id: orgId });
  return result.organizations.nodes[0].stores.nodes;
}

async function selectOrganizationPrompt(organizations) {
  if (organizations.length === 1) {
    return organizations[0];
  }
  const orgList = organizations.map((org) => ({ name: org.businessName, value: org.id }));
  const questions = {
    type: "autocomplete",
    name: "id",
    message: "Which Partners organization is this work for?",
    choices: orgList
  };
  const choice = await ui.prompt([questions]);
  return organizations.find((org) => org.id === choice.id);
}
async function selectAppPrompt(apps) {
  const appList = apps.map((app) => ({ name: app.title, value: app.apiKey }));
  const questions = {
    type: "autocomplete",
    name: "apiKey",
    message: "Which existing app is this for?",
    choices: appList
  };
  const choice = await ui.prompt([questions]);
  return apps.find((app) => app.apiKey === choice.apiKey);
}
async function selectStorePrompt(stores) {
  if (stores.length === 0)
    return void 0;
  if (stores.length === 1) {
    output.completed(`Using your default dev store (${stores[0].shopName}) to preview your project`);
    return stores[0];
  }
  const storeList = stores.map((store) => ({ name: store.shopName, value: store.shopId }));
  const questions = {
    type: "autocomplete",
    name: "id",
    message: "Which development store would you like to use to view your project?",
    choices: storeList
  };
  const choice = await ui.prompt([questions]);
  return stores.find((store) => store.shopId === choice.id);
}
async function appNamePrompt(currentName) {
  const questions = {
    type: "input",
    name: "name",
    message: "App Name",
    default: currentName,
    validate: (value) => {
      if (value.length === 0) {
        return "App Name can't be empty";
      }
      if (value.length > 30) {
        return "App name is too long (maximum is 30 characters)";
      }
      if (value.includes("shopify")) {
        return "Invalid app name";
      }
      return true;
    }
  };
  const input = await ui.prompt([questions]);
  return input.name;
}
async function reloadStoreListPrompt() {
  const options = [
    { name: "Yes, reload my stores", value: "reload" },
    { name: "No, cancel dev", value: "cancel" }
  ];
  const questions = {
    type: "select",
    name: "value",
    message: "Have you created a new dev store?",
    choices: options
  };
  const choice = await ui.prompt([questions]);
  return choice.value === "reload";
}
async function createAsNewAppPrompt() {
  const options = [
    { name: "Yes, create it as a new app", value: "yes" },
    { name: "No, connect it to an existing app", value: "cancel" }
  ];
  const questions = {
    type: "select",
    name: "value",
    message: "Create this project as a new app on Shopify?",
    choices: options
  };
  const choice = await ui.prompt([questions]);
  return choice.value === "yes";
}

async function selectOrCreateApp(localApp, apps, orgId, token, cachedApiKey) {
  if (cachedApiKey) {
    const cachedApp = await fetchAppFromApiKey(cachedApiKey, token);
    if (cachedApp)
      return cachedApp;
  }
  let createNewApp = apps.length === 0;
  if (!createNewApp)
    createNewApp = await createAsNewAppPrompt();
  const app = createNewApp ? await createApp(orgId, localApp, token) : await selectAppPrompt(apps);
  return app;
}
async function createApp(orgId, app, token) {
  const name = await appNamePrompt(app.name);
  const variables = {
    org: parseInt(orgId, 10),
    title: `${name}`,
    appUrl: "https://shopify.github.io/shopify-cli/help/start-app/",
    redir: ["http://localhost:3456"]
  };
  const query = api.graphql.CreateAppQuery;
  const result = await api.partners.request(query, token, variables);
  if (result.appCreate.userErrors.length > 0) {
    const errors = result.appCreate.userErrors.map((error2) => error2.message).join(", ");
    throw new error.Abort(errors);
  }
  output.success(`${result.appCreate.app.title} has been created on your Partners account`);
  return result.appCreate.app;
}

const ConvertToDevError = (storeName, message) => {
  return new error.Bug(`Error converting store ${storeName} to a Test store: ${message}`, "This store might not be compatible with draft apps, please try a different store");
};
const StoreNotFoundError = (storeName, org) => {
  return new error.Bug(`Could not find ${storeName} in the Organization ${org.businessName} as a valid development store.`, `Visit https://partners.shopify.com/${org.id}/stores to create a new store in your organization`);
};
const InvalidStore = (storeName) => {
  return new error.Bug(`${storeName} can't be used to test draft apps`, "Please try with a different store.");
};
const CreateStoreLink = (orgId) => {
  const url = `https://partners.shopify.com/${orgId}/stores/new?store_type=dev_store`;
  return `Click here to create a new dev store to preview your project:
${url}
`;
};
async function selectStore(stores, org, token, cachedStoreName) {
  if (cachedStoreName) {
    await convertToTestStoreIfNeeded(cachedStoreName, stores, org, token);
    return cachedStoreName;
  }
  const store = await selectStorePrompt(stores);
  if (store) {
    await convertToTestStoreIfNeeded(store.shopDomain, stores, org, token);
    return store.shopDomain;
  }
  output.info(`
${CreateStoreLink(org.id)}`);
  const reload = await reloadStoreListPrompt();
  if (!reload)
    throw new error.AbortSilent();
  const data = await fetchAllStores(org.id, token);
  return selectStore(data, org, token);
}
async function convertToTestStoreIfNeeded(storeDomain, stores, org, token) {
  const store = stores.find((store2) => store2.shopDomain === storeDomain);
  if (!store)
    throw StoreNotFoundError(storeDomain, org);
  if (!store.transferDisabled && !store.convertableToPartnerTest)
    throw InvalidStore(store.shopDomain);
  if (!store.transferDisabled)
    await convertStoreToTest(store, org.id, token);
}
async function convertStoreToTest(store, orgId, token) {
  const query = api.graphql.ConvertDevToTestStoreQuery;
  const variables = {
    input: {
      organizationID: parseInt(orgId, 10),
      shopId: store.shopId
    }
  };
  const result = await api.partners.request(query, token, variables);
  if (!result.convertDevToTestStore.convertedToTestStore) {
    const errors = result.convertDevToTestStore.userErrors.map((error2) => error2.message).join(", ");
    throw ConvertToDevError(store.shopDomain, errors);
  }
  output.success(`Converted ${store.shopDomain} to a Test store`);
}

const InvalidApiKeyError = (apiKey) => {
  return new error.Abort(`Invalid API key: ${apiKey}`, "You can find the apiKey in the app settings in the Partner Dashboard.");
};
async function ensureDevEnvironment(options) {
  const token = await session.ensureAuthenticatedPartners();
  const cachedInfo = getAppDevCachedInfo({
    reset: options.reset,
    directory: options.app.directory,
    apiKey: options.apiKey ?? store.getAppInfo(options.app.directory)?.appId
  });
  const explanation = `
Looks like this is the first time you're running dev for this project.
Configure your preferences by answering a few questions.
`;
  if (cachedInfo === void 0 && !options.reset) {
    output.info(explanation);
  }
  const orgId = cachedInfo?.orgId || await selectOrg(token);
  const { organization, apps, stores } = await fetchOrgsAppsAndStores(orgId, token);
  let { app: selectedApp, store: selectedStore } = await dataFromInput(options, organization, stores, token);
  if (selectedApp && selectedStore) {
    options = await updateDevOptions({ ...options, apiKey: selectedApp.apiKey });
    store.setAppInfo({ appId: selectedApp.apiKey, directory: options.app.directory, storeFqdn: selectedStore, orgId });
    return {
      app: {
        ...selectedApp,
        apiSecret: selectedApp.apiSecretKeys.length === 0 ? void 0 : selectedApp.apiSecretKeys[0].secret
      },
      store: selectedStore,
      identifiers: {
        app: selectedApp.apiKey,
        extensions: {}
      }
    };
  }
  selectedApp = selectedApp || await selectOrCreateApp(options.app, apps, orgId, token, cachedInfo?.appId);
  store.setAppInfo({ appId: selectedApp.apiKey, directory: options.app.directory, orgId });
  options = await updateDevOptions({ ...options, apiKey: selectedApp.apiKey });
  selectedStore = selectedStore || await selectStore(stores, organization, token, cachedInfo?.storeFqdn);
  store.setAppInfo({ appId: selectedApp.apiKey, directory: options.app.directory, storeFqdn: selectedStore });
  if (selectedApp.apiKey === cachedInfo?.appId && selectedStore === cachedInfo.storeFqdn) {
    showReusedValues(organization.businessName, options.app, selectedStore);
  }
  return {
    app: {
      ...selectedApp,
      apiSecret: selectedApp.apiSecretKeys.length === 0 ? void 0 : selectedApp.apiSecretKeys[0].secret
    },
    store: selectedStore,
    identifiers: {
      app: selectedApp.apiKey,
      extensions: {}
    }
  };
}
async function updateDevOptions(options) {
  const updatedApp = await updateAppIdentifiers({
    app: options.app,
    identifiers: {
      app: options.apiKey,
      extensions: {}
    },
    environmentType: "production"
  });
  return {
    ...options,
    app: updatedApp
  };
}
async function ensureDeployEnvironment(options) {
  const token = await session.ensureAuthenticatedPartners();
  const envIdentifiers = await getAppIdentifiers({ app: options.app, environmentType: "production" });
  const areIdentifiersMissing = getAreIdentifiersMissing(options.app, envIdentifiers);
  let identifiers;
  let partnersApp;
  if (areIdentifiersMissing) {
    const orgId = await selectOrg(token);
    const { apps } = await fetchOrgsAppsAndStores(orgId, token);
    let appId;
    if (envIdentifiers.app) {
      appId = envIdentifiers.app;
      partnersApp = await fetchAppFromApiKey(appId, token);
    } else {
      partnersApp = await selectOrCreateApp(options.app, apps, orgId, token, void 0);
      appId = partnersApp.apiKey;
    }
    identifiers = {
      app: appId,
      extensions: {}
    };
    options = {
      ...options,
      app: await updateAppIdentifiers({ app: options.app, identifiers, environmentType: "production" })
    };
  } else {
    identifiers = envIdentifiers;
    partnersApp = await fetchAppFromApiKey(identifiers.app, token);
  }
  return {
    app: options.app,
    partnersApp: {
      id: partnersApp.id,
      title: partnersApp.title,
      appType: partnersApp.appType
    },
    identifiers
  };
}
function getAreIdentifiersMissing(app, identifiers) {
  const appIdMissing = identifiers.app === void 0;
  const anyExtensionMissingId = (extensions) => {
    return extensions.every((extension) => {
      return (identifiers?.extensions ?? {})[extension.localIdentifier] !== void 0;
    });
  };
  const anyExtensionIdMissing = anyExtensionMissingId(app.extensions.ui) || anyExtensionMissingId(app.extensions.theme) || anyExtensionMissingId(app.extensions.function);
  return appIdMissing || anyExtensionIdMissing;
}
async function fetchOrgsAppsAndStores(orgId, token) {
  let data = {};
  const list = new ui.Listr([
    {
      title: "Fetching organization data",
      task: async () => {
        const responses = await Promise.all([fetchOrgAndApps(orgId, token), fetchAllStores(orgId, token)]);
        data = { ...responses[0], stores: responses[1] };
      }
    }
  ], { rendererSilent: environment.local.isUnitTest() });
  await list.run();
  return data;
}
async function dataFromInput(options, org, stores, token) {
  let selectedApp;
  let selectedStore;
  if (options.apiKey) {
    selectedApp = await fetchAppFromApiKey(options.apiKey, token);
    if (!selectedApp)
      throw InvalidApiKeyError(options.apiKey);
  }
  if (options.store) {
    await convertToTestStoreIfNeeded(options.store, stores, org, token);
    selectedStore = options.store;
  }
  return { app: selectedApp, store: selectedStore };
}
function getAppDevCachedInfo({
  reset,
  directory,
  apiKey
}) {
  if (!apiKey)
    return void 0;
  if (apiKey && reset)
    store.clearAppInfo(directory);
  return store.getAppInfo(directory);
}
async function selectOrg(token) {
  const orgs = await fetchOrganizations(token);
  const org = await selectOrganizationPrompt(orgs);
  return org.id;
}
function showReusedValues(org, app, store) {
  output.info("\nUsing your previous dev settings:");
  output.info(`Org:        ${org}`);
  output.info(`App:        ${app.name}`);
  output.info(`Dev store:  ${store}
`);
  output.info(output.content`To reset your default dev config, run ${output.token.command(app.dependencyManager, "dev", "--reset")}\n`);
}

export { ensureDevEnvironment as a, ensureDeployEnvironment as e };
//# sourceMappingURL=environment-52fb1530.js.map
